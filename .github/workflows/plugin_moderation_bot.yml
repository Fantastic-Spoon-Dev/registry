name: Plugin Moderation Bot

on:
  issue_comment:
    types: [created]

permissions:
  issues: write # To comment on issues
  contents: read # To read repository content (though not strictly needed for this basic version, good to have if you expand)

jobs:
  process_plugin_request:
    # Only run if the comment is on an issue (not a PR)
    # and the comment starts with the approval command
    # and the commenter has appropriate permissions (OWNER, MEMBER, COLLABORATOR)
    if: |
      !github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '/approve-plugin') &&
      (
        github.event.comment.author_association == 'OWNER' ||
        github.event.comment.author_association == 'MEMBER' ||
        github.event.comment.author_association == 'COLLABORATOR'
      )
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse command and issue data, then call API
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PLUGIN_API_KEY: ${{ secrets.YOUR_PLUGIN_API_KEY }} # IMPORTANT: Store your API key as a secret
          API_ENDPOINT: "https://exp.kp.itzdrli.cc/api/add-plugin"
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.

          ISSUE_BODY=$(gh issue view ${{ github.event.issue.number }} --json body --jq .body)
          COMMENT_BODY="${{ github.event.comment.body }}"

          echo "Issue Body: $ISSUE_BODY"
          echo "Comment Body: $COMMENT_BODY"

          # --- Extract packageName from issue body ---
          # This assumes the issue template creates a parsable structure.
          # A more robust way is to parse the structured YAML from the issue form submission if GitHub API allows.
          # For now, we'll try a regex based on the markdown output of the input field.
          # The exact regex might need adjustment based on how GitHub renders the issue body from the form.
          # Typically it's like: ### NPM Package Name\n\nkoishi-plugin-name
          PACKAGE_NAME_RAW=$(echo "$ISSUE_BODY" | grep -i -A 1 "NPM Package Name" | tail -n 1 | xargs)
          # If the above is unreliable, an alternative might be to parse the issue body for specific markers.
          # For issue forms, GitHub often renders them like:
          # **NPM Package Name**
          # actual-package-name
          # PACKAGE_NAME_RAW=$(echo "$ISSUE_BODY" | awk '/\*\*NPM Package Name\*\*/{getline; print}' | tr -d '\r' | xargs)

          # Try another common pattern for issue forms output:
          if [[ -z "$PACKAGE_NAME_RAW" || "$PACKAGE_NAME_RAW" == "NPM Package Name" ]]; then
            PACKAGE_NAME_RAW=$(echo "$ISSUE_BODY" | sed -n -e '/### NPM Package Name/,/###/ s/### NPM Package Name//p' | sed -n '2p' | awk '{$1=$1};1')
          fi
          echo "Raw Package Name from Issue: '$PACKAGE_NAME_RAW'"
          if [[ -z "$PACKAGE_NAME_RAW" ]]; then
            echo "::error::Could not extract package name from issue body."
            gh issue comment ${{ github.event.issue.number }} --body "❌ Error: Could not extract `packageName` from the issue body. Please ensure it was filled correctly."
            exit 1
          fi

          # --- Validate packageName format ---
          # Allowed formats: @scope/koishi-plugin-*, koishi-plugin-*, @koishijs/plugin-*
          if ! [[ "$PACKAGE_NAME_RAW" =~ ^@([a-zA-Z0-9_-]+)\/koishi-plugin-([a-zA-Z0-9_-]+)$ || \
                  "$PACKAGE_NAME_RAW" =~ ^koishi-plugin-([a-zA-Z0-9_-]+)$ || \
                  "$PACKAGE_NAME_RAW" =~ ^@koishijs\/plugin-([a-zA-Z0-9_-]+)$ ]]; then
            echo "::error::Invalid package name format: $PACKAGE_NAME_RAW"
            gh issue comment ${{ github.event.issue.number }} --body "❌ Error: Invalid `packageName` format: \`$PACKAGE_NAME_RAW\`. Allowed formats are \`@scope/koishi-plugin-*\`, \`koishi-plugin-*\`, or \`@koishijs/plugin-*\`."
            exit 1
          fi
          PACKAGE_NAME="$PACKAGE_NAME_RAW"
          echo "Validated Package Name: $PACKAGE_NAME"

          # --- Extract initial category from issue body ---
          # This also assumes a parsable structure from the issue template output
          # INITIAL_CATEGORY_RAW=$(echo "$ISSUE_BODY" | awk '/\*\*Category\*\*/{getline; print}' | tr -d '\r' | xargs)
          # Try another common pattern for issue forms output:
          INITIAL_CATEGORY_RAW=$(echo "$ISSUE_BODY" | sed -n -e '/### Category/,/###/ s/### Category//p' | sed -n '2p' | awk '{$1=$1};1')
          if [[ -z "$INITIAL_CATEGORY_RAW" || "$INITIAL_CATEGORY_RAW" == "Category" ]]; then
             echo "::warning::Could not extract initial category from issue. Will rely on command or default."
             INITIAL_CATEGORY_RAW="" # Set to empty if not found
          fi
          echo "Initial Category from Issue: '$INITIAL_CATEGORY_RAW'"


          # --- Parse command arguments ---
          VERIFIED_ARG=$(echo "$COMMENT_BODY" | grep -oP 'verified:\s*\K(true|false)')
          RATING_ARG=$(echo "$COMMENT_BODY" | grep -oP 'rating:\s*\K([0-9]+(\.[0-9]+)?)')
          CATEGORY_ARG=$(echo "$COMMENT_BODY" | grep -oP 'category:\s*\K(\S+)') # \S+ matches non-whitespace

          if [[ -z "$VERIFIED_ARG" || -z "$RATING_ARG" ]]; then
            echo "::error::Missing verified or rating in command."
            gh issue comment ${{ github.event.issue.number }} --body "❌ Error: Command is missing \`verified\` or \`rating\`. Usage: \`/approve-plugin verified:[true|false] rating:[0.0-5.0] [category:new-category]\`"
            exit 1
          fi

          # Use category from command if provided, otherwise from issue, otherwise error if neither
          FINAL_CATEGORY="$CATEGORY_ARG"
          if [[ -z "$FINAL_CATEGORY" ]]; then
            FINAL_CATEGORY="$INITIAL_CATEGORY_RAW"
          fi

          if [[ -z "$FINAL_CATEGORY" ]]; then
            echo "::error::Category not provided in command and not found in issue."
            gh issue comment ${{ github.event.issue.number }} --body "❌ Error: \`category\` was not provided in the command and could not be found in the original issue submission."
            exit 1
          fi

          echo "Using Package Name: $PACKAGE_NAME"
          echo "Using Verified: $VERIFIED_ARG"
          echo "Using Rating: $RATING_ARG"
          echo "Using Category: $FINAL_CATEGORY"

          # --- Construct JSON payload ---
          JSON_PAYLOAD=$(cat <<EOF
          {
            "packageName": "$PACKAGE_NAME",
            "rating": $RATING_ARG,
            "verified": $VERIFIED_ARG,
            "apiKey": "$PLUGIN_API_KEY",
            "category": "$FINAL_CATEGORY"
          }
          EOF
          )

          echo "Payload: $JSON_PAYLOAD"

          # --- Send POST request ---
          HTTP_RESPONSE=$(curl -s -w "%{http_code}" -X POST "$API_ENDPOINT" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")

          HTTP_STATUS=$(echo "$HTTP_RESPONSE" | tail -n1)
          HTTP_BODY=$(echo "$HTTP_RESPONSE" | sed '$d') # Get all but last line

          echo "API Response Status: $HTTP_STATUS"
          echo "API Response Body: $HTTP_BODY"

          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            MESSAGE="✅ Plugin \`$PACKAGE_NAME\` submitted successfully to the registry with rating \`$RATING_ARG\`, verified status \`$VERIFIED_ARG\`, and category \`$FINAL_CATEGORY\`."
            gh issue comment ${{ github.event.issue.number }} --body "$MESSAGE"
            gh issue close ${{ github.event.issue.number }} --reason "completed"
            echo "$MESSAGE"
          else
            MESSAGE="❌ Error submitting plugin \`$PACKAGE_NAME\` to the registry. API responded with status \`$HTTP_STATUS\`."
            ERROR_DETAILS="API Response: \`$HTTP_BODY\`"
            gh issue comment ${{ github.event.issue.number }} --body "$MESSAGE\n$ERROR_DETAILS"
            echo "::error::$MESSAGE $ERROR_DETAILS"
            exit 1
          fi