name: Plugin Moderation Bot

on:
  issue_comment:
    types: [created]

permissions:
  issues: write # To comment on issues and close them
  contents: read

jobs:
  process_plugin_request:
    if: |
      !github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '/approve-plugin') &&
      (
        github.event.comment.author_association == 'OWNER' ||
        github.event.comment.author_association == 'MEMBER' ||
        github.event.comment.author_association == 'COLLABORATOR'
      )
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse command and issue data, then call API
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PLUGIN_API_KEY: ${{ secrets.YOUR_PLUGIN_API_KEY }}
          API_ENDPOINT: "https://exp.kp.itzdrli.cc/api/add-plugin"
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.

          ISSUE_NUMBER=${{ github.event.issue.number }}
          COMMENT_BODY="${{ github.event.comment.body }}"

          echo "Fetching issue body for issue #$ISSUE_NUMBER..."
          ISSUE_BODY_JSON=$(gh issue view "$ISSUE_NUMBER" --json body)
          ISSUE_BODY=$(echo "$ISSUE_BODY_JSON" | jq -r .body)

          echo "Issue Body (first 300 chars): $(echo "$ISSUE_BODY" | head -c 300)..."
          echo "Comment Body: $COMMENT_BODY"

          # --- Function to extract value after a header, skipping blank lines ---
          # $1: Full issue body
          # $2: Header text (e.g., "### NPM Package Name")
          extract_value_after_header() {
            local body="$1"
            local header_pattern="^${2}$" # Match the exact header line
            # sed: Find header, then print first non-blank line after it
            # n: read next line
            # :loop; /^\s*$/{n; b loop}: if line is blank, read next and loop
            # p: print non-blank line
            # q: quit
            echo "$body" | sed -n -e "/${header_pattern}/{n; :loop; /^\s*$/{n; b loop}; p; q}" | xargs
          }

          # --- Extract packageName from issue body ---
          PACKAGE_NAME_RAW=$(extract_value_after_header "$ISSUE_BODY" "### NPM Package Name")
          echo "Raw Package Name from Issue: '$PACKAGE_NAME_RAW'"

          if [[ -z "$PACKAGE_NAME_RAW" || "$PACKAGE_NAME_RAW" == "NPM Package Name" ]]; then # Second check less likely with sed
            ERROR_MESSAGE="❌ Error: Could not extract \`packageName\` from the issue body.
            The bot expected to find a header '### NPM Package Name' followed by the package name in the issue's Markdown.
            Please ensure the issue was created using the correct template and the 'NPM Package Name' field was filled.
            Raw value extracted: '$PACKAGE_NAME_RAW'"
            echo "::error::$ERROR_MESSAGE"
            gh issue comment "$ISSUE_NUMBER" --body "$ERROR_MESSAGE"
            exit 1
          fi

          # --- Validate packageName format ---
          if ! [[ "$PACKAGE_NAME_RAW" =~ ^@([a-zA-Z0-9_.-]+)\/koishi-plugin-([a-zA-Z0-9_.-]+)$ || \
                  "$PACKAGE_NAME_RAW" =~ ^koishi-plugin-([a-zA-Z0-9_.-]+)$ || \
                  "$PACKAGE_NAME_RAW" =~ ^@koishijs\/plugin-([a-zA-Z0-9_.-]+)$ ]]; then
            ERROR_MESSAGE="❌ Error: Invalid \`packageName\` format: \`$PACKAGE_NAME_RAW\`.
            Allowed formats are \`@scope/koishi-plugin-*\`, \`koishi-plugin-*\`, or \`@koishijs/plugin-*\`."
            echo "::error::$ERROR_MESSAGE"
            gh issue comment "$ISSUE_NUMBER" --body "$ERROR_MESSAGE"
            exit 1
          fi
          PACKAGE_NAME="$PACKAGE_NAME_RAW"
          echo "Validated Package Name: $PACKAGE_NAME"

          # --- Extract initial category from issue body ---
          INITIAL_CATEGORY_RAW=$(extract_value_after_header "$ISSUE_BODY" "### Category")
          echo "Raw Initial Category from Issue: '$INITIAL_CATEGORY_RAW'"

          if [[ -z "$INITIAL_CATEGORY_RAW" || "$INITIAL_CATEGORY_RAW" == "Category" ]]; then # Second check less likely
             echo "::warning::Could not reliably extract initial category from issue. Will rely on command argument if provided."
             INITIAL_CATEGORY_RAW=""
          fi
          echo "Initial Category (after cleanup): '$INITIAL_CATEGORY_RAW'"

          # --- Parse command arguments ---
          VERIFIED_ARG=$(echo "$COMMENT_BODY" | grep -oP 'verified:\s*\K(true|false)')
          RATING_ARG=$(echo "$COMMENT_BODY" | grep -oP 'rating:\s*\K([0-9]+(\.[0-9]+)?)')
          CATEGORY_ARG_FROM_CMD=$(echo "$COMMENT_BODY" | grep -oP 'category:\s*\K([^ ]+)')

          if [[ -z "$VERIFIED_ARG" || -z "$RATING_ARG" ]]; then
            ERROR_MESSAGE="❌ Error: Command is missing \`verified\` or \`rating\`.
            Usage: \`/approve-plugin verified:[true|false] rating:[0.0-5.0] [category:new-category]\`"
            echo "::error::$ERROR_MESSAGE"
            gh issue comment "$ISSUE_NUMBER" --body "$ERROR_MESSAGE"
            exit 1
          fi

          FINAL_CATEGORY="$CATEGORY_ARG_FROM_CMD"
          if [[ -z "$FINAL_CATEGORY" ]]; then
            FINAL_CATEGORY="$INITIAL_CATEGORY_RAW"
          fi

          if [[ -z "$FINAL_CATEGORY" ]]; then
            ERROR_MESSAGE="❌ Error: \`category\` was not provided in the approval command and could not be reliably extracted from the original issue submission."
            echo "::error::$ERROR_MESSAGE"
            gh issue comment "$ISSUE_NUMBER" --body "$ERROR_MESSAGE"
            exit 1
          fi

          echo "Using Package Name: $PACKAGE_NAME"
          echo "Using Verified: $VERIFIED_ARG"
          echo "Using Rating: $RATING_ARG"
          echo "Using Category: $FINAL_CATEGORY"

          if [[ -z "$PLUGIN_API_KEY" ]]; then
            ERROR_MESSAGE="❌ Error: PLUGIN_API_KEY is not configured in the workflow secrets."
            echo "::error::$ERROR_MESSAGE"
            gh issue comment "$ISSUE_NUMBER" --body "$ERROR_MESSAGE"
            exit 1
          fi

          JSON_PAYLOAD=$(cat <<EOF
          {
            "packageName": "$PACKAGE_NAME",
            "rating": $RATING_ARG,
            "verified": $VERIFIED_ARG,
            "apiKey": "$PLUGIN_API_KEY",
            "category": "$FINAL_CATEGORY"
          }
          EOF
          )

          echo "Payload: $JSON_PAYLOAD"

          HTTP_RESPONSE_WITH_CODE=$(curl -s -w "\\n%{http_code}" -X POST "$API_ENDPOINT" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")

          HTTP_STATUS=$(echo "$HTTP_RESPONSE_WITH_CODE" | tail -n1)
          HTTP_BODY=$(echo "$HTTP_RESPONSE_WITH_CODE" | sed '$d')

          echo "API Response Status: $HTTP_STATUS"
          echo "API Response Body (first 200 chars): $(echo "$HTTP_BODY" | head -c 200)..."

          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            SUCCESS_MESSAGE="✅ Plugin \`$PACKAGE_NAME\` submitted successfully to the registry with rating \`$RATING_ARG\`, verified status \`$VERIFIED_ARG\`, and category \`$FINAL_CATEGORY\`."
            echo "$SUCCESS_MESSAGE"
            gh issue comment "$ISSUE_NUMBER" --body "$SUCCESS_MESSAGE"
            gh issue close "$ISSUE_NUMBER" --reason "completed"
          else
            SANITIZED_API_BODY=$(echo "$HTTP_BODY" | tr -d '`' | head -c 500)
            if [[ ${#HTTP_BODY} -gt 500 ]]; then SANITIZED_API_BODY="$SANITIZED_API_BODY..."; fi

            ERROR_MESSAGE="❌ Error submitting plugin \`$PACKAGE_NAME\` to the registry.
            API responded with status: \`$HTTP_STATUS\`
            API Response Body:
            \`\`\`
            $SANITIZED_API_BODY
            \`\`\`"
            echo "::error::Error submitting plugin. Status: $HTTP_STATUS. Body: $HTTP_BODY"
            gh issue comment "$ISSUE_NUMBER" --body "$ERROR_MESSAGE"
            exit 1
          fi